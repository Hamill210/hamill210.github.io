---
layout: post
title: [주꼭지 - 알고리즘] 이진 탐색, 빅오표기법
subtitle: 
cover-img: 
tags: [빅오표기법, 알고리즘, 이진탐색, 주꼭지]
---



## 알고리즘

어떤 일을 하기 위한 명령의 집합

## 이진 탐색

- 들어가며

전화번호부에서 누군가의 번호를 찾는다고 했을 때 어떻게 찾는 것이 좋을까요? 사전에 원하는 단어를 찾을 때 어떻게 찾는 것이 좋을까요? 페이스북은 우리가 로그인할 때 우리의 계정을 데이터베이스에서 어떻게 찾을까요? → 이런 문제를 탐색 문제라고 합니다. 이 경우 이진 탐색 알고리즘을 사용할 수 있습니다. 
<br>

- 이진 탐색은 어떻게 동작할까요?

우리가 만약 1부터 100까지 하나의 숫자를 찾는다고 가정한다면, 단순 탐색(simple search)은 1부터 원하는 숫자가 나올 때까지 모두 탐색합니다. 이진 탐색은 1과 100의 중간 50을 기준으로 원하는 값이 50보다 큰지 작은지 물어봅니다. 한 마디 대답으로 탐색해야 할 숫자들 절반이 사라집니다. 만약 50보다 크다면 51부터 100사이의 75를 기준으로 또 물어봅니다. 이진 탐색에서는 매번 남은 숫자 중의 가운데 숫자를 말하고 대답에 따라 그보다 큰 숫자 혹은 작은 숫자들을 한꺼번에 없앨 수 있습니다.  우리는 7단계만에 원하는 숫자를 찾을 수 있습니다(100 → 50 → 25 → 13 → 7 → 4 → 2 → 1 )
<br>

- 240,000개 숫자* 중 원하는 숫자를 찾으려면 몇 번 탐색해야 할까요?

총 18단계만에 원하는 값을 찾을 수 있습니다. (240,000 → 120,000 → 60,000 → 30,000 → 15,000 → 7,500 → 3,750 → 1875 → 938 → 469 → 235 → 118 → 59 → 30 → 15 → 8 → 4 → 2 → 1) 1번의 연산이 1 밀리초(1초는 1000밀리초)가 걸린다고 하면 18밀리초만 걸립니다. 단순 탐색은 얼마나 걸리지 생각해봅시다.  우리는 n 개의 원소를 가진 리스트에서 이진 탐색을 사용하면 최대 logn** 번 만에 답을 찾을 수 있습니다. 단순 탐색이면 최대 n 번이 필요할 수 있습니다.

```
* 이진 탐색은 리스트의 원소들이 정렬되어 있어야만 사용할 수 있습니다.
** 빅오 표기법에서 모든 log 함수의 밑은 2를 뜻합니다. 
```
<br>

- 실행 시간

이 책에서 알고리즘에 대해 말할 때는 항상 그 알고리즘의 실행 시간(running time)에 관해 설명하겠습니다. 아마 독자 여러분은 시간이나 저장 공간을 절약해 주는 가장 효율적인 알고리즘을 선택하고 싶을 겁니다. 만약 이진 탐색을 사용하면 얼마나 많은 시간을 절약할 수 있을까요?

단순 탐색으로 100개의 원소 리스트는 100번 추측을 해야하고, 40억개의 원소 리스트는 40억번 추측해야 합니다. 이런 것을 선형 시간(linear time, O(n))이라고 합니다. 이와 다르게 이진 탐색은 100개의 원소의 리스트를 7번만 추측해도 되고, 40억개의 원소 리스트는 32번만 추측하면 됩니다. 이진 탐색의 경우에는 로그 시간(logarithmic time, O(logn))으로 실행됩니다. 

## 빅오 표기법

- 들어가며

빅오표기법(Big O notation)은 알고리즘이 얼마나 빠른지 표시하는 특별한 방법입니다. 

한 가지 예를 들어봅시다. NASA에서 알고리즘을 만드는 밥은 달 착률 로켓에 사용할 탐색 알고리즘 중 무엇을 선택해야 할지 고민하고 있습니다. 선택의 기준은 빠르면서 정확해야 합니다. 만약 단순 탐색과 이진 탐색 중 하나만 골라야 한다면 우리라면 이진 탐색이 속도가 더 빠르기 때문에 이진 탐색을 선택하겠죠? 하지만 이진 탐색에 비해 버그가 덜 생기는 단순 탐색도 고려 대상에서 제외할 수 없습니다. 

밥은 실제로 동작을 확인하기 위해 두 알고리즘을 100개의 원소를 가진 리스트에 적용해 보기로 했습니다. 원소 하나를 확인하는데 1밀리 초가 걸린다고 가정해 봅시다. 단순 탐색을 사용하면 100개의 원소를 확인하는데 100밀리 초, 이진 탐색을 사용하면 7밀리 초가 걸립니다. 실제 데이터가 10억개 이상의 원소가 있다면 단순 탐색은 10억 밀리 초, 이진 탐색은 30밀리 초가 걸립니다. 

밥은 생각합니다. "그러니까 100개의 원소로 탐색해서 비교해보니 이진 탐색이 단순 탐색보다 15배 빠르네!!" 라고 생각하고 실제 데이터에다 이 공식을 적용하고 버그가 적은 단순 탐색을 사용하기로 결정했습니다. 과연 옳은 결정일까요?
<br>

- 리스트의 크기가 증가할 때 어떻게 증가하는지를 정확히 파악해야 한다

밥은 전혀 옳은 선택을 하지 않았습니다. 10억 개의 원소에 대해 단순 탐색 실행 시간은 10억 밀리 초 약 11일이 걸립니다. 이진 탐색과 단순 탐색의 실행 시간이 같은 비율로 증가하지 않기 때문이죠(이진 탐색은 32밀리 초, 단순 탐색보다 33,000,000배 빠릅니다). 우리는 원소의 개수가 커질수록 이진 탐색보다 단순 탐색이 훨씬 빨라지는 것을 알았습니다. 그래서 알고리즘의 실행 시간이 얼마나 걸리는지만 고려할 것이 아니라, 리스트의 크기가 증가할 때 어떻게 증가하는지를 파악할 필요가 있습니다. 빅오 표기법을 사용하는 이유가 바로 이것 때문입니다.
<br>

- 빅오 표기법은 알고리즘이 얼마나 빠른지를 말해줍니다.

리스트의 크기가 n 일때 단순 탐색은 n 번의 연산을 필요로 하기 때문에 빅오 표기법에 따른 실행 시간은 O(n)입니다. '초'와 같은 시간 단위를 붙이지 않는 이유는 속도를 시간 단위로 세지 않기 때문입니다. 빅오 표기법은 연산 횟수를 비교하기 위한 것입니다. 빅오 표기법을 사용하면 수행해야 할 일이 많아질 때 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지를 알 수 있습니다. 빅오 표기법은 알고리즘이 동작하기 위해 필요한 연산 횟수를 나타냅니다
<br>

- 최악의 실행 시간을 나타내는 빅오 표기법*

전화번호부에서 사람을 찾기 위해 단순 탐색을 사용하고 있다고 가정합시다. 단순 탐색의 실행 시간이 O(n) 시간이라는 것은 최악의 경우, 즉 전화번호부의 모든 사람의 이름을 확인하는 경우를 뜻합니다. 만약 Adit라는 이름을 찾는다면 전화번호부 맨 앞에 나올 수도 있습니다. 단번에 찾았기 때문에 그 이후의 이름을 확인할 필요가 없습니다. 이 때 알고리즘의 실행 시간은 O(n)일까요 O(1)일까요?

결론은 단순 탐색의 실행 시간은 어떤 경우에도 O(n)입니다. 한 번에 찾기는 했지만 최선의 경우였고 빅오 표기법은최악의 경우에 대한 것을 나타냅니다. 다시 말하면 최악의 경우 전화번호부에서 모든 이름을 확인해야 하는 것, 그것이 O(n) 시간입니다. 단순 탐색이 절대로 O(n) 시간보다 느려지지 않는다는 일종의 보장이 되는 것이죠.

```
* 최악의 경우에 대한 실행 시간 이외에도 평균 실행 시간을 살펴보는 것도 중요합니다.
  최악의 경우와 평균에 대한 비교는 4장에서 다룹니다.
```
<br>

- 많이 사용하는 빅오 실행 시간의 예 (가장 흔한 5가지 빅오 실행 시간)
    - O(log n) 로그 시간 : 예(이진 탐색)
    - O(n) 선형 시간 : 예(단순 탐색)
    - O(n * log n) : 예(퀵 정렬과 같이 빠른 정렬 알고리즘)
    - O(n^2) : 예(선택 정렬과 같이 느린 정렬 알고리즘)
    - O(n!) : 예(외판원 문제와 같이 정말 느린 알고리즘)

![Graph of Big O Complexity over Time](https://miro.medium.com/max/1400/1*WXfVqSBSsQBLKnPMM4rRKA.png)

- 위 다섯 개의 알고리즘을 사용해서 16개의 네모 칸을 만드는 문제를 생각해보자

```
네모 칸의 수  O(log n)   O(n)    O(nlog n)  O(n^2)   O(n!)
         16   0.4초     1.6초   6.4초      25.6초   66301년 
        256   0.8초     25.6초  3.4분      1.8시간  2.7x10^498년
       1024   1.0초     1.7분   17분       1.2일    1.72x10^2631년
```

## 이번 장의 핵심 요약

- 이진 탐색은 단순 탐색보다 아주 빠릅니다.
- O(log n)은 O(n)보다 빠릅니다. 리스트의 원소 개수가 증가하면 상대적으로 더 빨라집니다.
- 알고리즘의 속도는 시간이 아니라 연산 횟수가 어떻게 증가하는지로 측정합니다.
- 이렇게 하면 입력 데이터의 크기가 늘어날 때 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있습니다.
- 알고리즘의 시간은 빅오 표기법으로 나타냅니다.

## 이번 장이 끝나면 대답할 수 있는 지식

- 알고리즘이란?
- 이진 탐색이란? 그리고 단순 탐색과의 차이점
- 선형 시간과 로그 시간이란?
- 빅오표기법이란?
- 알고리즘의 속도 측정 방법과 그 방법을 사용하는 이유
- 외판원 문제란?

## 참고
- Hello Coding 그림으로 개념을 이해하는 알고리즘 1장
- https://medium.com/@verdi/understanding-big-o-notation-for-the-newbie-dev-720c6f3446fd
